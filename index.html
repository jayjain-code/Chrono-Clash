<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chrono Clash</title>
    <style>
        :root {
            --bg-color: #1a1a1d;
            --text-color: #e0e0e0;
            --accent-blue: #4facfe;
            --accent-red: #ff4b4b;
            --past-tone: #d4a373;
            --past-bg: #faedcd;
            --present-tone: #4ecdc4;
            --present-bg: #f7fff7;
            --future-tone: #b5179e;
            --future-bg: #2d0036;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
            user-select: none;
        }

        /* --- Header & UI --- */
        header {
            width: 100%;
            padding: 15px 0;
            text-align: center;
            background: linear-gradient(90deg, #111, #222);
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }

        h1 { margin: 0; font-weight: 800; letter-spacing: 2px; text-transform: uppercase; font-size: 1.5rem; }
        .subtitle { font-size: 0.9rem; color: #888; font-weight: 400; }

        #game-ui {
            display: flex;
            justify-content: space-between;
            width: 95%;
            max-width: 1000px;
            margin-bottom: 10px;
            align-items: center;
        }

        .player-card {
            background: #333;
            padding: 10px 20px;
            border-radius: 8px;
            border-left: 5px solid transparent;
            min-width: 120px;
            position: relative;
            transition: all 0.3s ease;
        }

        .player-card.active { transform: scale(1.05); box-shadow: 0 0 15px rgba(255,255,255,0.1); }
        .p1-card { border-color: var(--accent-blue); }
        .p1-card.active { background: rgba(79, 172, 254, 0.2); }
        .p2-card { border-color: var(--accent-red); }
        .p2-card.active { background: rgba(255, 75, 75, 0.2); }

        .ap-display { font-size: 1.2rem; font-weight: bold; margin-top: 5px; }
        .ap-pip { display: inline-block; width: 12px; height: 12px; border-radius: 50%; background: #555; margin-right: 4px; }
        .ap-pip.filled { background: #fff; box-shadow: 0 0 5px #fff; }

        #turn-indicator {
            font-size: 1.2rem;
            font-weight: bold;
            text-transform: uppercase;
            padding: 5px 15px;
            border-radius: 20px;
            background: #444;
        }

        /* --- Game Boards Container --- */
        #boards-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            padding: 10px;
            width: 100%;
            max-width: 1200px;
        }

        .timeline-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .timeline-label {
            margin-bottom: 8px;
            font-weight: bold;
            font-size: 1rem;
            padding: 4px 12px;
            border-radius: 4px;
            text-transform: uppercase;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
            width: 280px;
            height: 280px;
            padding: 8px;
            border-radius: 8px;
            position: relative;
            transition: transform 0.2s;
        }

        /* Timeline Themes */
        .theme-past .timeline-label { background: var(--past-tone); color: #3e2723; }
        .theme-past .board { background: var(--past-bg); border: 4px solid var(--past-tone); }
        .theme-past .cell { background: rgba(212, 163, 115, 0.3); border-color: rgba(62, 39, 35, 0.1); }
        
        .theme-present .timeline-label { background: var(--present-tone); color: #004d40; }
        .theme-present .board { background: var(--present-bg); border: 4px solid var(--present-tone); }
        .theme-present .cell { background: rgba(78, 205, 196, 0.1); border-color: rgba(0, 77, 64, 0.1); }

        .theme-future .timeline-label { background: var(--future-tone); color: #fff; }
        .theme-future .board { background: var(--future-bg); border: 4px solid var(--future-tone); }
        .theme-future .cell { background: rgba(181, 23, 158, 0.15); border-color: rgba(255, 255, 255, 0.1); }

        /* --- Cells & Units --- */
        .cell {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .cell:hover { background: rgba(255,255,255,0.15); }
        
        /* Valid Moves Highlights */
        .cell.highlight-move { background: rgba(79, 172, 254, 0.4) !important; box-shadow: inset 0 0 10px var(--accent-blue); animation: pulse 1.5s infinite; }
        .cell.highlight-attack { background: rgba(255, 75, 75, 0.4) !important; box-shadow: inset 0 0 10px var(--accent-red); animation: pulse-red 1.5s infinite; }
        .cell.highlight-shift { background: rgba(180, 80, 255, 0.4) !important; box-shadow: inset 0 0 10px #b050ff; animation: pulse-purple 1.5s infinite; }

        /* Special Tiles */
        .cell.causality-node::before {
            content: '';
            position: absolute;
            width: 60%;
            height: 60%;
            border: 2px dashed rgba(0,0,0,0.3);
            border-radius: 50%;
            animation: spin 10s linear infinite;
        }
        .theme-future .cell.causality-node::before { border-color: rgba(255,255,255,0.3); }

        .unit {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            position: relative;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 2;
        }

        .unit.p1 { background: var(--accent-blue); color: #fff; border: 2px solid #8ec5ff; }
        .unit.p2 { background: var(--accent-red); color: #fff; border: 2px solid #ff9e9e; }
        
        .unit.selected { transform: scale(1.15); box-shadow: 0 0 15px currentColor; z-index: 10; }
        .unit.exhausted { opacity: 0.6; filter: grayscale(0.5); }

        .hp-bar {
            position: absolute;
            bottom: -5px;
            left: 10%;
            width: 80%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
        }
        .hp-fill { height: 100%; background: #0f0; transition: width 0.3s; }
        .p1 .hp-fill { background: #8ec5ff; }
        .p2 .hp-fill { background: #ff9e9e; }

        /* Icons */
        .icon { width: 60%; height: 60%; fill: currentColor; }

        /* Effects */
        .buff-icon {
            position: absolute;
            top: -8px;
            right: -8px;
            font-size: 10px;
            background: #ffd700;
            color: #000;
            padding: 2px 4px;
            border-radius: 4px;
            font-weight: bold;
            animation: bounce 2s infinite;
        }

        /* --- Footer & Info --- */
        #log-area {
            width: 95%;
            max-width: 600px;
            height: 80px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            margin-top: 20px;
            padding: 10px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.9rem;
            border: 1px solid #444;
        }
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 2px; }
        .log-p1 { color: #8ec5ff; }
        .log-p2 { color: #ff9e9e; }
        .log-sys { color: #aaa; font-style: italic; }

        .btn {
            background: #444;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            margin-top: 15px;
            transition: background 0.2s;
        }
        .btn:hover { background: #555; }
        .btn-end { background: #d32f2f; }
        .btn-end:hover { background: #b71c1c; }

        #modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        #modal-overlay.visible { opacity: 1; pointer-events: all; }
        
        .modal-content {
            background: #222;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #555;
            max-width: 500px;
        }
        .modal-title { font-size: 2rem; margin-bottom: 10px; }
        .modal-msg { margin-bottom: 20px; color: #ccc; }

        /* Keyframes */
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 0.8; } 100% { opacity: 0.5; } }
        @keyframes pulse-red { 0% { opacity: 0.5; } 50% { opacity: 0.9; } 100% { opacity: 0.5; } }
        @keyframes pulse-purple { 0% { opacity: 0.4; } 50% { opacity: 0.7; } 100% { opacity: 0.4; } }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-3px); } }

        /* Responsive */
        @media (max-width: 900px) {
            #boards-container { gap: 10px; }
            .board { width: 220px; height: 220px; }
        }
        @media (max-width: 700px) {
            #boards-container { flex-direction: column; align-items: center; }
            .board { width: 300px; height: 300px; }
        }
    </style>
</head>
<body>

<header>
    <h1>Chrono Clash</h1>
    <div class="subtitle">Temporal Strategy Warfare</div>
</header>

<div id="game-ui">
    <div class="player-card p1-card active" id="p1-card">
        <div>PLAYER 1 (Blue)</div>
        <div class="ap-display" id="p1-ap">
            <span class="ap-pip filled"></span><span class="ap-pip filled"></span><span class="ap-pip filled"></span>
        </div>
    </div>

    <div id="turn-indicator">P1 Turn</div>

    <div class="player-card p2-card" id="p2-card">
        <div>PLAYER 2 (Red)</div>
        <div class="ap-display" id="p2-ap">
            <span class="ap-pip filled"></span><span class="ap-pip filled"></span><span class="ap-pip filled"></span>
        </div>
    </div>
</div>

<div id="boards-container">
    <!-- Past Board -->
    <div class="timeline-wrapper theme-past">
        <div class="timeline-label">Past (Buffs Atk)</div>
        <div class="board" id="board-past"></div>
    </div>

    <!-- Present Board -->
    <div class="timeline-wrapper theme-present">
        <div class="timeline-label">Present (Main)</div>
        <div class="board" id="board-present"></div>
    </div>

    <!-- Future Board -->
    <div class="timeline-wrapper theme-future">
        <div class="timeline-label">Future (Decay)</div>
        <div class="board" id="board-future"></div>
    </div>
</div>

<button class="btn btn-end" onclick="game.endTurn()">End Turn (Spacebar)</button>

<div id="log-area">
    <div class="log-entry log-sys">Welcome to Chrono Clash. Destroy the enemy Chronosphere in the Present!</div>
</div>

<!-- Intro Modal / Game Over Modal -->
<div id="modal-overlay" class="visible">
    <div class="modal-content">
        <h2 class="modal-title" id="modal-title">CHRONO CLASH</h2>
        <div class="modal-msg" id="modal-msg">
            <p><strong>Objective:</strong> Destroy the enemy <strong>Chronosphere</strong> in the Present timeline.</p>
            <p><strong>Mechanics:</strong><br>
            â€¢ <strong>Move:</strong> 1 AP<br>
            â€¢ <strong>Attack:</strong> 1 AP<br>
            â€¢ <strong>Time Shift:</strong> 2 AP (0 for Walker)<br>
            â€¢ <strong>Past Node:</strong> Gives +1 ATK to future selves.<br>
            </p>
            <p>Use Time Shifts to flank enemies!</p>
        </div>
        <button class="btn" onclick="game.startGame()">Start Game</button>
    </div>
</div>

<!-- SVG Icons -->
<div style="display: none;">
    <!-- Sword -->
    <svg id="icon-striker" viewBox="0 0 24 24"><path d="M14.5 13.5L3 25l-1-1 11.5-11.5L14.5 13.5zm7-11L13 11l-2.5-2.5L19 0l2.5 2.5zM17.5 7L23 1.5 22.5 1 17 6.5l.5.5z"/></svg>
    <!-- Shield -->
    <svg id="icon-guardian" viewBox="0 0 24 24"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z"/></svg>
    <!-- Infinity/Walker -->
    <svg id="icon-walker" viewBox="0 0 24 24"><path d="M18 4c-4 0-7 3-8 6-1-3-4-6-8-6-3.31 0-6 2.69-6 6s2.69 6 6 6c4 0 7-3 8-6 1 3 4 6 8 6 3.31 0 6-2.69 6-6s-2.69-6-6-6zm-2.5 8c-.83 0-1.5-.67-1.5-1.5S14.67 9 15.5 9s1.5.67 1.5 1.5-.67 1.5-1.5 1.5zM6 14c-.83 0-1.5-.67-1.5-1.5S5.17 11 6 11s1.5.67 1.5 1.5S6.83 14 6 14z"/></svg>
    <!-- Base -->
    <svg id="icon-base" viewBox="0 0 24 24"><path d="M12 2L1 21h22L12 2zm0 3.99L19.53 19H4.47L12 5.99zM12 15c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>
</div>

<script>
/**
 * CHRONO CLASH - Game Logic
 */

// --- Constants ---
const BOARD_SIZE = 5;
const TIMELINES = ['past', 'present', 'future'];
const MAX_AP = 3;

// --- Unit Definitions ---
const UNITS = {
    GUARDIAN: { type: 'Guardian', hp: 5, dmg: 1, move: 1, cost: 3, icon: 'icon-guardian', desc: 'Tank' },
    STRIKER: { type: 'Striker', hp: 3, dmg: 2, move: 1, cost: 2, icon: 'icon-striker', desc: 'Dps' },
    WALKER: { type: 'Walker', hp: 3, dmg: 1, move: 1, cost: 3, icon: 'icon-walker', desc: 'Shifter' },
    BASE: { type: 'Chronosphere', hp: 6, dmg: 0, move: 0, cost: 0, icon: 'icon-base', desc: 'Objective' }
};

class Game {
    constructor() {
        this.state = {
            turn: 1, // 1 or 2
            ap: MAX_AP,
            selectedUnit: null,
            gameOver: false,
            units: []
        };
        
        // Setup causal nodes (fixed positions)
        this.nodes = {
            past: { x: 2, y: 2 }, // Center
            present: { x: 2, y: 2 }, // Center
            future: null
        };

        this.initDOM();
    }

    initDOM() {
        this.boards = {};
        TIMELINES.forEach(t => {
            const el = document.getElementById(`board-${t}`);
            this.boards[t] = el;
            this.renderGrid(t, el);
        });

        // Keyboard listener for end turn
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !this.state.gameOver) {
                e.preventDefault(); // Prevent scrolling
                this.endTurn();
            }
        });
    }

    renderGrid(timeline, container) {
        container.innerHTML = '';
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.timeline = timeline;
                cell.dataset.x = x;
                cell.dataset.y = y;
                
                // Add node visuals
                if (this.nodes[timeline] && this.nodes[timeline].x === x && this.nodes[timeline].y === y) {
                    cell.classList.add('causality-node');
                    cell.title = timeline === 'past' ? "Past Nexus: +1 ATK to Present/Future" : "Present Nexus: +1 DEF to Future";
                }

                cell.onclick = () => this.handleCellClick(timeline, x, y);
                container.appendChild(cell);
            }
        }
    }

    startGame() {
        document.getElementById('modal-overlay').classList.remove('visible');
        this.resetGame();
    }

    resetGame() {
        this.state.turn = 1;
        this.state.ap = MAX_AP;
        this.state.gameOver = false;
        this.state.units = [];
        this.state.selectedUnit = null;

        // --- Initial Army Setup ---
        
        // Player 1 (Blue) - Starts Top
        this.spawnUnit(1, 'BASE', 'present', 2, 0); // Base
        this.spawnUnit(1, 'GUARDIAN', 'past', 2, 0);
        this.spawnUnit(1, 'STRIKER', 'present', 1, 0);
        this.spawnUnit(1, 'STRIKER', 'present', 3, 0);
        this.spawnUnit(1, 'WALKER', 'future', 2, 0);

        // Player 2 (Red) - Starts Bottom
        this.spawnUnit(2, 'BASE', 'present', 2, 4); // Base
        this.spawnUnit(2, 'GUARDIAN', 'future', 2, 4);
        this.spawnUnit(2, 'STRIKER', 'present', 1, 4);
        this.spawnUnit(2, 'STRIKER', 'present', 3, 4);
        this.spawnUnit(2, 'WALKER', 'past', 2, 4);

        this.updateUI();
        this.renderUnits();
        this.log("Game Started. Player 1's Turn.", "sys");
    }

    spawnUnit(player, typeKey, timeline, x, y) {
        const template = UNITS[typeKey];
        const unit = {
            id: Math.random().toString(36).substr(2, 9),
            player: player,
            type: template.type,
            maxHp: template.hp,
            currentHp: template.hp,
            dmg: template.dmg,
            moveRange: template.move,
            isWalker: template.type === 'Walker',
            timeline: timeline,
            x: x,
            y: y,
            hasMoved: false,
            hasAttacked: false,
            icon: template.icon
        };
        this.state.units.push(unit);
        return unit;
    }

    getUnitAt(timeline, x, y) {
        return this.state.units.find(u => u.timeline === timeline && u.x === x && u.y === y);
    }

    // --- Core Logic ---

    handleCellClick(timeline, x, y) {
        if (this.state.gameOver) return;

        const clickedUnit = this.getUnitAt(timeline, x, y);
        const isCurrentPlayerUnit = clickedUnit && clickedUnit.player === this.state.turn;

        // 1. Select Unit
        if (isCurrentPlayerUnit) {
            if (this.state.selectedUnit && this.state.selectedUnit.id === clickedUnit.id) {
                this.deselect(); // Toggle off
            } else {
                this.selectUnit(clickedUnit);
            }
            return;
        }

        // 2. Action (Move/Attack) if unit selected
        if (this.state.selectedUnit) {
            this.tryAction(timeline, x, y, clickedUnit);
        }
    }

    selectUnit(unit) {
        // Can only select if we have AP (unless pure checking, but keeping it simple)
        if (this.state.ap <= 0) {
            this.log("No Action Points remaining!", "sys");
            return;
        }

        this.state.selectedUnit = unit;
        this.renderUnits(); // Re-render to show selection
        this.highlightOptions(unit);
    }

    deselect() {
        this.state.selectedUnit = null;
        this.clearHighlights();
        this.renderUnits();
    }

    highlightOptions(unit) {
        this.clearHighlights();

        // Standard Moves (Adjacent)
        const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
        
        // Check Move & Attack on current board
        dirs.forEach(([dx, dy]) => {
            const nx = unit.x + dx;
            const ny = unit.y + dy;

            if (this.isValidCoord(nx, ny)) {
                const target = this.getUnitAt(unit.timeline, nx, ny);
                const cell = this.getCell(unit.timeline, nx, ny);
                
                if (!target) {
                    // Empty - Move
                    if (this.state.ap >= 1 && unit.type !== 'Chronosphere') {
                        cell.classList.add('highlight-move');
                    }
                } else if (target.player !== unit.player) {
                    // Enemy - Attack
                    if (this.state.ap >= 1 && unit.dmg > 0) {
                        cell.classList.add('highlight-attack');
                    }
                }
            }
        });

        // Time Shift
        // Cost: 2 AP normally, 0 AP if Walker (but limit 1 shift per turn maybe? Let's say 0 AP cost logic handled in execute)
        const shiftCost = unit.isWalker ? 0 : 2;
        
        if (this.state.ap >= shiftCost && unit.type !== 'Chronosphere') {
            const timeIndex = TIMELINES.indexOf(unit.timeline);
            const adjTimelines = [];
            if (timeIndex > 0) adjTimelines.push(TIMELINES[timeIndex - 1]);
            if (timeIndex < 2) adjTimelines.push(TIMELINES[timeIndex + 1]);

            adjTimelines.forEach(t => {
                const target = this.getUnitAt(t, unit.x, unit.y);
                if (!target) {
                    const cell = this.getCell(t, unit.x, unit.y);
                    cell.classList.add('highlight-shift');
                }
            });
        }
    }

    tryAction(timeline, x, y, targetUnit) {
        const unit = this.state.selectedUnit;
        
        // Determine Action Type
        const dx = Math.abs(unit.x - x);
        const dy = Math.abs(unit.y - y);
        const isAdj = (dx + dy === 1) && (unit.timeline === timeline);
        const isShift = (unit.x === x && unit.y === y) && (unit.timeline !== timeline);

        // 1. Attack
        if (targetUnit && targetUnit.player !== unit.player && isAdj) {
            if (this.state.ap >= 1) {
                this.executeAttack(unit, targetUnit);
            }
        }
        // 2. Move
        else if (!targetUnit && isAdj) {
            if (this.state.ap >= 1) {
                this.executeMove(unit, timeline, x, y);
            }
        }
        // 3. Shift
        else if (!targetUnit && isShift) {
            // Check adjacency of timelines
            const t1 = TIMELINES.indexOf(unit.timeline);
            const t2 = TIMELINES.indexOf(timeline);
            if (Math.abs(t1 - t2) === 1) {
                const cost = unit.isWalker ? 0 : 2;
                if (this.state.ap >= cost) {
                    this.executeShift(unit, timeline, cost);
                }
            }
        }

        // Cleanup
        this.deselect();
    }

    executeMove(unit, timeline, x, y) {
        unit.x = x;
        unit.y = y;
        this.state.ap -= 1;
        this.log(`${unit.type} moved to (${x}, ${y})`, `p${unit.player}`);
        this.updateState();
    }

    executeAttack(attacker, defender) {
        // Calculate Buffs
        const buffs = this.calculateBuffs(attacker);
        const defenseBuffs = this.calculateDefenseBuffs(defender);
        
        let dmg = attacker.dmg + buffs.atk;
        // Shield reduces damage
        if (defenseBuffs.def > 0) dmg = Math.max(1, dmg - defenseBuffs.def); // Minimum 1 dmg if hit

        defender.currentHp -= dmg;
        this.state.ap -= 1;

        // Visual feedback
        this.log(`${attacker.type} hits ${defender.type} for ${dmg} DMG!`, `p${attacker.player}`);
        
        if (defender.currentHp <= 0) {
            this.killUnit(defender);
        }
        this.updateState();
    }

    executeShift(unit, newTimeline, cost) {
        const oldT = unit.timeline;
        unit.timeline = newTimeline;
        this.state.ap -= cost;
        this.log(`${unit.type} shifted ${oldT} â†’ ${newTimeline}`, `p${unit.player}`);
        this.updateState();
    }

    killUnit(unit) {
        this.state.units = this.state.units.filter(u => u !== unit);
        this.log(`${unit.type} destroyed!`, "sys");
        
        if (unit.type === 'Chronosphere') {
            this.triggerGameOver(unit.player === 1 ? 2 : 1);
        }
    }

    // --- Causal Mechanics ---
    calculateBuffs(unit) {
        let atk = 0;
        // Check Past Node
        const pastNode = this.nodes.past;
        // Find unit on past node
        const occupier = this.getUnitAt('past', pastNode.x, pastNode.y);
        
        // If the occupier is friendly, and we are in Present or Future
        if (occupier && occupier.player === unit.player && (unit.timeline === 'present' || unit.timeline === 'future')) {
            atk += 1;
        }
        return { atk };
    }

    calculateDefenseBuffs(unit) {
        let def = 0;
        // Check Present Node
        const presentNode = this.nodes.present;
        const occupier = this.getUnitAt('present', presentNode.x, presentNode.y);

        // If occupier is friendly, and we are in Future
        if (occupier && occupier.player === unit.player && unit.timeline === 'future') {
            def += 1;
        }
        return { def };
    }

    // --- Game Flow ---

    endTurn() {
        if (this.state.gameOver) return;
        
        this.deselect();
        this.state.turn = this.state.turn === 1 ? 2 : 1;
        this.state.ap = MAX_AP;
        
        const pName = this.state.turn === 1 ? "Player 1 (Blue)" : "Player 2 (Red)";
        document.getElementById('turn-indicator').innerText = this.state.turn === 1 ? "P1 Turn" : "P2 Turn";
        
        // Visual toggle
        document.getElementById('p1-card').classList.toggle('active');
        document.getElementById('p2-card').classList.toggle('active');
        
        this.log(`--- ${pName} Turn ---`, "sys");
        this.updateUI();
    }

    triggerGameOver(winner) {
        this.state.gameOver = true;
        document.getElementById('modal-title').innerText = winner === 1 ? "PLAYER 1 WINS!" : "PLAYER 2 WINS!";
        document.getElementById('modal-msg').innerHTML = `<p style="color:${winner===1?'var(--accent-blue)':'var(--accent-red)'}">Timeline dominance secured.</p>`;
        document.getElementById('modal-overlay').classList.add('visible');
    }

    // --- Helpers & Render ---

    updateState() {
        this.renderUnits();
        this.updateUI();
    }

    updateUI() {
        // Update AP Pips
        const p1Ap = this.state.turn === 1 ? this.state.ap : 0;
        const p2Ap = this.state.turn === 2 ? this.state.ap : 0;
        
        this.renderAp('p1-ap', this.state.turn === 1 ? this.state.ap : (this.state.ap === 0 && this.state.turn===1 ? 0 : "-"));
        this.renderAp('p2-ap', this.state.turn === 2 ? this.state.ap : (this.state.ap === 0 && this.state.turn===2 ? 0 : "-"));
    }

    renderAp(id, count) {
        const el = document.getElementById(id);
        el.innerHTML = '';
        if (count === "-") return; // Not turn
        for(let i=0; i<3; i++) {
            const pip = document.createElement('span');
            pip.className = `ap-pip ${i < count ? 'filled' : ''}`;
            el.appendChild(pip);
        }
    }

    renderUnits() {
        // Clear old units from DOM (only visual units, grid remains)
        document.querySelectorAll('.unit').forEach(e => e.remove());

        this.state.units.forEach(unit => {
            const cell = this.getCell(unit.timeline, unit.x, unit.y);
            if (!cell) return;

            const el = document.createElement('div');
            el.className = `unit p${unit.player}`;
            if (this.state.selectedUnit === unit) el.classList.add('selected');
            
            // Icon
            const svgRef = document.getElementById(unit.icon);
            if (svgRef) el.innerHTML = `<svg class="icon" viewBox="0 0 24 24">${svgRef.innerHTML}</svg>`;

            // HP Bar
            const hpPct = (unit.currentHp / unit.maxHp) * 100;
            const hpBar = document.createElement('div');
            hpBar.className = 'hp-bar';
            hpBar.innerHTML = `<div class="hp-fill" style="width:${hpPct}%"></div>`;
            el.appendChild(hpBar);

            // Buff Indicators
            const buffs = this.calculateBuffs(unit);
            const defs = this.calculateDefenseBuffs(unit);
            if (buffs.atk > 0) {
                const buffEl = document.createElement('div');
                buffEl.className = 'buff-icon';
                buffEl.innerText = `+${buffs.atk}âš”ï¸`;
                el.appendChild(buffEl);
            } else if (defs.def > 0) {
                const buffEl = document.createElement('div');
                buffEl.className = 'buff-icon';
                buffEl.innerText = `+${defs.def}ðŸ›¡ï¸`;
                el.appendChild(buffEl);
            }

            cell.appendChild(el);
        });
    }

    getCell(timeline, x, y) {
        return document.querySelector(`.cell[data-timeline="${timeline}"][data-x="${x}"][data-y="${y}"]`);
    }

    clearHighlights() {
        document.querySelectorAll('.cell').forEach(c => {
            c.classList.remove('highlight-move', 'highlight-attack', 'highlight-shift');
        });
    }

    isValidCoord(x, y) {
        return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE;
    }

    log(msg, type) {
        const area = document.getElementById('log-area');
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        entry.innerText = `> ${msg}`;
        area.prepend(entry);
    }
}

// Start
const game = new Game();

</script>
</body>
</html>
